(* EBNF representation of UML 2.5 Behavior StateMachine *)
(* Copyright 2018 Ryan Chaves *)
@@grammar::UML_SM


(* Language keywords *)
@@keyword               :: stm
@@keyword               :: conn_point
@@keyword               :: initial
@@keyword               :: final
@@keyword               :: deepHistory
@@keyword               :: shallowHistory
@@keyword               :: join
@@keyword               :: fork
@@keyword               :: junction
@@keyword               :: choice
@@keyword               :: entryPoint
@@keyword               :: exitPoint
@@keyword               :: terminate
@@keyword               :: state
@@keyword               :: region
@@keyword               :: entry
@@keyword               :: exit
@@keyword               :: do

(* Grammar *)
file_input              = state_machine $
                        ;
state_machine           = 'stm' ~ stm_name:id_base '{' {region_member:region_member}+ '}'
                        ;
region_member           = vertex
                        | transition
                        | fork_decl
                        | choice_decl
                        ;
vertex                  = pseudostate
                        | state
                        | submachine_state
                        ;
conn_point              = 'conn_point' 'entry' entry_conn_point:id_base
                        | 'conn_point' 'exit'  exit_conn_point:id_base
                        ;
pseudostate             = 'deepHistory'     ~ deepHistory:id_base
                        | 'shallowHistory'  ~ shallowHistory:id_base
                        | 'join'            ~ join:id_base ['->' target:id [effect:effect_decl]]
                        | 'fork'            ~ fork:id_base
                        | 'junction'        ~ junction:id_base
                        | 'choice'          ~ choice:id_base
                        | entrypoint:entrypoint_decl
                        | exitpoint:exitpoint_decl
                        | 'terminate'
                        ;
fork_decl               = 'fork' ~ fork:id_base '{' {transition:fork_transition}+ '}'
                        ;
fork_transition         = '->' target:id [effect:effect_decl]
                        ;
choice_decl             = 'choice' ~ choice:id_base '{' {transition:choice_transition}+ '}'
                        ;
choice_transition       = '->' target:id '?' guard:guard_decl
                        ;
entrypoint_decl         = 'entryPoint' ~ src:id_base '->' target:id [effect:effect_decl]
                        | 'entryPoint' ~ src:id_base '->' target:id [guard:guard_decl effect:effect_decl]
                        ;
exitpoint_decl          = 'exitPoint'  ~ src:id_base ['->' target:id [effect:effect_decl]]
                        | 'exitPoint'  ~ src:id_base ['->' target:id [guard:guard_decl effect:effect_decl]]
                        ;
state                   = 'state' ~ state:id_base ['{' {region_member:region_member|region:region|behavior:behavior}+ '}']
                        ;
region                  = 'region' ~ region:id_base '{' {region_member:region_member}+ '}'
                        ;
submachine_state        = 'submachine' ~ state:id_base submachine_name:id_base ['{' {conn_point:conn_point_decl}+ '}']
                        ;
conn_point_decl         = 'entryPoint' ~ entryPoint:id_base
                        | 'exitPoint'  ~ exitPoint:id_base
                        ;
transition              = local_transition:local_transition
                        | external_transition:external_transition
                        | internal_transition:internal_transition
                        ;
internal_transition     = trigger:trigger
                        ;
local_transition        = src:'initial' ~ '->' target:id        [':' trigger:trigger]
                        | src:id          '->' target:'final' ~ [':' trigger:trigger]
                        ;
external_transition     = src:id '->' target:id [':' trigger:trigger]
                        ;
trigger                 = trigger:id_base {',' trigger:id_base}* [guard:guard_decl] [effect:effect_decl]
                        ;
behavior                = kind:('entry'|'exit'|'doActivity') ~ effect:effect_decl
                        ;

(* Tokens & Expressions *)
id                      = id:id_base {[r:id_region] [s:id_scope]}*
                        | c:id_conn_point
                        ;
id_region               = '[' id:id ']'
                        ;
id_scope                = '::' id:id
                        ;
id_conn_point           = id:id '.' id_base
                        ;
@name
id_base                 = /\w+/
                        ;
expr                    = /.+/
                        ;
guard_decl              = '[' @:guard_expr ']'
                        ;
guard_expr              = /[^\]\n]+/
                        ;
effect_decl             = '/' @:expr
                        ;
