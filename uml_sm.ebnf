(* EBNF representation of UML 2.5 Behavior StateMachine *)
(* Copyright 2018 Ryan Chaves *)
@@grammar::UML_SM


(* Language keywords *)
@@keyword               :: stm
@@keyword               :: conn_point
@@keyword               :: initial
@@keyword               :: final
@@keyword               :: deepHistory
@@keyword               :: shallowHistory
@@keyword               :: join
@@keyword               :: fork
@@keyword               :: junction
@@keyword               :: choice
@@keyword               :: entryPoint
@@keyword               :: exitPoint
@@keyword               :: terminate
@@keyword               :: state
@@keyword               :: region
@@keyword               :: entry
@@keyword               :: exit
@@keyword               :: do

(* Grammar *)
file_input              = {state_machine}+ $
                        ;
state_machine           = 'stm' stm_name:id_base '{' s:{statement}+ '}'
                        ;
statement               = v:vertex
                        | t:transition
                        ;
vertex                  = p:pseudostate
                        | s:state
                        | ss:submachine_state
                        ;
conn_point              = 'conn_point' 'entry' entry_conn_point:id
                        | 'conn_point' 'exit'  exit_conn_point:id
                        ;
pseudostate             = 'deepHistory' deepHistory:id
                        | 'shallowHistory' shallowHistory:id
                        | join
                        | fork
                        | 'junction' junction:id
                        | choice
                        | entrypoint
                        | exitpoint
                        | 'terminate'
                        ;
join                    = 'join' join:id ['->' target:id [effect_decl]]
                        ;
fork                    = 'fork' fork:id ['{' fork_transition {fork_transition}+ '}']
                        ;
fork_transition         = '->' target:id [effect_decl]
                        ;
choice                  = 'choice' choice:id ['{' {choice_transition}+ '}']
                        ;
choice_transition       = '->' target:id '?' guard_decl
                        ;
entrypoint              = 'entryPoint' src:id '->' target:id [effect_decl]
                        | 'entryPoint' src:id '->' target:id [guard_decl effect_decl]
                        ;
exitpoint               = 'exitPoint'  src:id ['->' target:id [effect_decl]]
                        | 'exitPoint'  src:id ['->' target:id [guard_decl effect_decl]]
                        ;
state                   = 'state' state:id_base ['{' {s:statement|r:region|b:behavior}+ '}']
                        ;
region                  = 'region' region:id_base '{' {s:statement}+ '}'
                        ;
submachine_state        = 'submachine' state:id_base submachine_name:id_base ['{' {c:conn_point_decl}+ '}']
                        ;
conn_point_decl         = 'entryPoint' entryPoint:id_base
                        | 'exitPoint'  exitPoint:id_base
                        ;
transition              = l:local_transition
                        | e:external_transition
                        | i:internal_transition
                        ;
internal_transition     = t:trigger
                        ;
local_transition        = src:'initial' '->' target:id      [':' trigger]
                        | src:id        '->' target:'final' [':' trigger]
                        ;
external_transition     = src:id '->' target:id [':' t:trigger]
                        ;
trigger                 = trigger:id_base {',' trigger:id_base}* [g:guard_decl] [e:effect_decl]
                        ;
behavior                = ('entry'|'exit'|'do') [effect_decl]
                        ;

(* Tokens & Expressions *)
id                      = id_base {[r:id_region] [s:id_scope]}*
                        | c:id_conn_point
                        ;
id_region               = '[' id:id ']'
                        ;
id_scope                = '::' id:id
                        ;
id_conn_point           = id:id '.' id_base
                        ;
@name
id_base                 = /\w+/
                        ;
expr                    = /.+/
                        ;
guard_decl              = '[' @:guard_expr ']'
                        ;
guard_expr              = /[^\]\n]+/
                        ;
effect_decl             = '/' @:expr
                        ;
